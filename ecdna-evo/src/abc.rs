//! Perform the approximate Bayesian computation to infer the most probable
//! fitness and death coefficients from the data.
use crate::data::{Differs, EcDNA, Entropy, Frequency, FromFile, Mean};
use crate::run::Run;
use crate::simulation::write2file;
use std::collections::HashMap;
use std::path::{Path, PathBuf};

/// A collection of `Measurement`s representing the data available for a cancer
/// patient.
pub struct Patient {
    ecdna: Option<EcDNA>,
    mean: Option<Mean>,
    frequency: Option<Frequency>,
    entropy: Option<Entropy>,
}

impl Patient {
    pub fn load(paths: PatientPaths, verbosity: u8) -> Self {
        //! Load patient's data from paths
        let mut found_one = false;
        let ecdna = {
            match paths.distribution {
                Some(path) => {
                    found_one = true;
                    if verbosity > 0u8 {
                        println!("Loading ecdna distribution");
                    }
                    Some(EcDNA::from_file(&path))
                }

                None => None,
            }
        };

        let mean = {
            match paths.mean {
                Some(path) => {
                    found_one = true;
                    if verbosity > 0u8 {
                        println!("Loading mean");
                    }
                    Some(Mean::from_file(&path))
                }
                None => None,
            }
        };

        let frequency = {
            match paths.frequency {
                Some(path) => {
                    found_one = true;
                    if verbosity > 0u8 {
                        println!("Loading frequency");
                    }
                    Some(Frequency::from_file(&path))
                }
                None => None,
            }
        };

        let entropy = {
            match paths.entropy {
                Some(path) => {
                    found_one = true;
                    if verbosity > 0u8 {
                        println!("Loading entropy");
                    }
                    Some(Entropy::from_file(&path))
                }
                None => None,
            }
        };

        assert!(found_one, "Must provide at least one path to load data");

        Patient {
            ecdna,
            mean,
            frequency,
            entropy,
        }
    }
}

/// Patient's paths to ABC input data
#[derive(Builder, Default)]
#[builder(derive(Debug))]
pub struct PatientPaths {
    #[builder(setter(into, strip_option), default)]
    distribution: Option<PathBuf>,
    #[builder(setter(into, strip_option), default)]
    mean: Option<PathBuf>,
    #[builder(setter(into, strip_option), default)]
    frequency: Option<PathBuf>,
    #[builder(setter(into, strip_option), default)]
    entropy: Option<PathBuf>,
    // #[builder(setter(into, strip_option), default)]
    // exponential: Option<PathBuf>,
}

/// Perform the ABC rejection algorithm for one run to infer the most probable
/// values of the rates based on the patient's data.
///
/// ABC infer the most probable values of the birth-death rates (proliferation
/// rates and death rates) by comparing the summary statistics of the run
/// generated by the birth-death process against the summary statistics of the
/// patient's data.
///
/// When testing multiple statistics with ABC, save runs only if all statistics
/// pass the tests
pub struct ABCRejection;

impl ABCRejection {
    pub fn run(run: Run, patient: &Patient) -> ABCResults {
        //! Run the ABC rejection method by comparing the run against the
        //! patient's data
        let mut results = HashMap::with_capacity(4);
        if let Some(ecdna) = &patient.ecdna {
            let (different, distance) = ecdna.is_different(&run);
            results.insert("ecdna".to_string(), (!(different) as u8, distance));
        }

        if let Some(mean) = &patient.mean {
            let (different, distance) = mean.is_different(&run);
            results.insert("mean".to_string(), (!(different) as u8, distance));
        }

        if let Some(frequency) = &patient.frequency {
            let (different, distance) = frequency.is_different(&run);
            results.insert("frequency".to_string(), (!(different) as u8, distance));
        }

        if let Some(entropy) = &patient.entropy {
            let (different, distance) = entropy.is_different(&run);
            results.insert("entropy".to_string(), (!(different) as u8, distance));
        }

        assert!(!results.is_empty(), "Found no data for the patient");
        ABCResults(results)
    }
}

/// Results of the ABC rejection algorithm, i.e. the posterior distributions of
/// the rates. There is one `ABCResults` for each run.
pub struct ABCResults(HashMap<String, (u8, f32)>);

impl ABCResults {
    pub fn save(&self, filename: &Path, path2folder: &Path, rates: &[f32]) -> bool {
        //! Save the results of the abc inference for a run generating the
        //! following files:
        //!
        //! 1. metadata: stores whether the statistics that are similar (1)
        //! or different (0) for ABC (ground truth vs simulation) for each run
        //!
        //! 2. values: the values of the summary statistics for each run
        //!
        //! 3. all_rates: the rates of all runs, also those that have been
        //! rejected and thus do not contribute to the posterior distribution
        //!
        //! 4. rates: the posterior distribution of the rates, here the rates
        //! are only those that contribute to the posterior distribution as
        //! opposed to file all_rates
        let header: String = self
            .0
            .keys()
            .fold(String::new(), |accum, stat| accum + stat + ",");

        // write metadata
        write2file(
            &self
                .0
                .values()
                .map(|(is_different, _)| is_different)
                .collect::<Vec<&u8>>(),
            &path2folder.join("metadata").join(filename),
            Some(&header),
        )
        .unwrap();

        write2file(
            &self
                .0
                .values()
                .map(|(_, distance)| distance)
                .collect::<Vec<&f32>>(),
            &path2folder.join("values").join(filename),
            Some(&header),
        )
        .unwrap();

        // save all runs to plot the histograms for each individual statistic
        // Save the proliferation and death rates of the cells w/ ecDNA and
        // w/o ecDNA respectively
        write2file(
            rates,
            &path2folder.join("all_rates").join(filename),
            Some("f1,f2,d1,d2"),
        )
        .unwrap();

        // write rates only if all stats pass the test
        if self.positive() {
            write2file(rates, &path2folder.join("rates").join(filename), None).unwrap();
            true
        } else {
            false
        }
    }

    pub fn positive(&self) -> bool {
        //! A positive result means that the run is similar to the patient's
        //! data
        self.0.values().all(|&result| result.0 > 0u8)
    }
}
