//! Perform the approximate Bayesian computation to infer the most probable
//! fitness and death coefficients from the data.
use crate::data::{Distance, EcDNADistribution, Entropy, Frequency, Mean};
use crate::patient::SequencingData;
use crate::run::{Ended, Run};
use crate::NbIndividuals;
use anyhow::Context;
use csv;
use rand::rngs::SmallRng;
use rand::SeedableRng;
use serde::Serialize;
use std::convert::TryFrom;
use std::fs::{self, OpenOptions};
use std::path::{Path, PathBuf};

/// Perform the ABC rejection algorithm for one run to infer the most probable
/// values of the rates based on the patient's data.
///
/// ABC infer the most probable values of the birth-death rates (proliferation
/// rates and death rates) by comparing the summary statistics of the run
/// generated by the birth-death process against the summary statistics of the
/// patient's data.
///
/// When testing multiple statistics with ABC, save runs only if all statistics
/// pass the tests
pub struct ABCRejection;

impl ABCRejection {
    pub fn run(run: &Run<Ended>, sample: &SequencingData) -> ABCResult {
        //! Run the ABC rejection method by comparing the run against the
        //! patient's data
        let mut builder = ABCResultBuilder::default();
        if let Some(ecdna) = &sample.ecdna {
            builder.ecdna(ecdna.distance(run));
        }

        if let Some(mean) = &sample.mean {
            builder.mean(mean.distance(run));
        }

        if let Some(frequency) = &sample.frequency {
            builder.frequency(frequency.distance(run));
        }

        if let Some(entropy) = &sample.entropy {
            builder.entropy(entropy.distance(run));
        }

        let idx = run.idx.to_string();
        if let Some(run) = run.get_parental_run() {
            builder.parental_idx(*run);
        }

        let mut result =
            builder.build().expect("Cannot run ABC without any data");
        let rates = run.rates();
        result.f1 = rates[0];
        result.f2 = rates[1];
        result.d1 = rates[2];
        result.d2 = rates[3];
        result.cells = *sample.get_tumour_size();

        result.idx = idx;
        result
    }
}

/// Results of the ABC rejection algorithm, i.e. the posterior distributions of
/// the rates. There is one `ABCResults` for each run.
pub struct ABCResults(Vec<ABCResult>);

impl ABCResults {
    pub fn with_capacity(capacity: usize) -> Self {
        ABCResults(Vec::with_capacity(capacity))
    }

    pub fn test(&mut self, run: &Run<Ended>, sample: &SequencingData) {
        self.0.push(ABCRejection::run(run, sample));
    }
}

#[derive(Builder, Debug, Serialize)]
pub struct ABCResult {
    #[builder(setter(strip_option), default)]
    parental_idx: Option<usize>,
    #[builder(setter(skip))]
    idx: String,
    #[builder(setter(strip_option), default)]
    ecdna: Option<f32>,
    #[builder(setter(strip_option), default)]
    mean: Option<f32>,
    #[builder(setter(strip_option), default)]
    frequency: Option<f32>,
    #[builder(setter(strip_option), default)]
    entropy: Option<f32>,
    #[builder(setter(skip))]
    f1: f32,
    #[builder(setter(skip))]
    f2: f32,
    #[builder(setter(skip))]
    d1: f32,
    #[builder(setter(skip))]
    d2: f32,
    #[builder(setter(skip))]
    cells: NbIndividuals,
}

impl ABCResults {
    pub fn save(
        &self,
        path2folder: &Path,
        subsamples: Option<&NbIndividuals>,
    ) -> anyhow::Result<()> {
        //! Save the results of the abc inference for a run in a folder abc, where there is one file for each (parental) run and the name of the file corresponds to the parental run.
        let path2save = path2folder.to_owned();
        // let path2save = if subsamples.is_some() {
        //     path2folder.to_owned().join("samples")
        // } else {
        //     path2folder.to_owned()
        // };
        let filename = match self.0[0].parental_idx {
            Some(run) => run.to_string(),
            None => self.0[0].idx.clone(),
        };
        let mut path2file = path2save.join(filename);
        path2file.set_extension("csv");
        fs::create_dir_all(path2file.parent().unwrap())
            .expect("Cannot create dir");
        let mut wtr = if path2file.exists() {
            let wrt = OpenOptions::new()
                .write(true)
                .append(true)
                .open(&path2file)
                .unwrap();

            csv::WriterBuilder::new().has_headers(false).from_writer(wrt)
        } else {
            csv::Writer::from_path(path2file)?
        };
        for record in self.0.iter() {
            wtr.serialize(record)?;
            wtr.flush()?;
        }
        Ok(())
    }
}
