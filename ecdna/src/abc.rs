//! Perform the approximate Bayesian computation to infer the most probable
//! fitness and death coefficients from the data.
use ecdna_data::data::{EcDNADistribution, Entropy, Frequency, Mean};
use ecdna_data::patient::SequencingData;
use ecdna_dynamics::run::{DNACopy, Ended, Run};
use ecdna_sim::{NbIndividuals, Seed};
use serde::Serialize;
use std::fs::{self, OpenOptions};
use std::path::Path;

/// Perform the ABC rejection algorithm for one run to infer the most probable
/// values of the rates based on the patient's data.
///
/// ABC infer the most probable values of the birth-death rates (proliferation
/// rates and death rates) by comparing the summary statistics of the run
/// generated by the birth-death process against the summary statistics of the
/// patient's data.
///
/// When testing multiple statistics with ABC, save runs only if all statistics
/// pass the tests
pub struct ABCRejection;

impl ABCRejection {
    pub fn run(
        run: &Run<Ended>,
        sample: &SequencingData,
        timepoint: usize,
    ) -> ABCResult {
        //! Run the ABC rejection method by comparing the run against the
        //! patient's data
        let mut builder = ABCResultBuilder::default();
        if let Some(ecdna) = &sample.ecdna {
            builder.ecdna(ecdna.distance(run));
        }

        if let Some(mean) = &sample.mean {
            builder.mean(mean.distance(run));
        }

        if let Some(frequency) = &sample.frequency {
            builder.frequency(frequency.distance(run));
        }

        if let Some(entropy) = &sample.entropy {
            builder.entropy(entropy.distance(run));
        }

        let seed = *run.get_seed();
        let idx = run.idx.to_string();
        if let Some(run) = run.get_parental_run() {
            builder.parental_idx(*run);
        }

        let mut result =
            builder.build().expect("Cannot run ABC without any data");
        let rates = run.rates();
        result.f1 = rates[0];
        result.f2 = rates[1];
        result.d1 = rates[2];
        result.d2 = rates[3];
        result.cells = run.nb_cells();
        result.tumour_cells = *sample.get_tumour_size();

        result.seed = seed;
        result.idx = idx;
        result.timepoint = timepoint;

        let ntot = run.init_state.get_distribution().nb_cells();
        result.init_mean = run
            .init_state
            .get_distribution()
            .mean()
            .expect("Cannot compute the mean of the initial distribution")
            .0;
        result.init_cells = ntot;
        result.init_copies = run
            .init_state
            .get_distribution()
            .get_unique_nplus_copies()
            .cloned();

        result
    }
}

/// Results of the ABC rejection algorithm, i.e. the posterior distributions of
/// the rates. There is one `ABCResults` for each run.
#[derive(Debug)]
pub struct ABCResults(Vec<ABCResult>);

impl ABCResults {
    pub fn with_capacity(capacity: usize) -> Self {
        ABCResults(Vec::with_capacity(capacity))
    }

    pub fn test(
        &mut self,
        run: &Run<Ended>,
        sample: &SequencingData,
        timepoint: usize,
    ) {
        self.0.push(ABCRejection::run(run, sample, timepoint));
    }
}

#[derive(Builder, Debug, Serialize)]
pub struct ABCResult {
    #[builder(setter(strip_option), default)]
    parental_idx: Option<usize>,
    #[builder(setter(skip))]
    idx: String,
    #[builder(setter(skip))]
    timepoint: usize,
    #[builder(setter(skip))]
    seed: Seed,
    #[builder(setter(strip_option), default)]
    ecdna: Option<f32>,
    #[builder(setter(strip_option), default)]
    mean: Option<f32>,
    #[builder(setter(strip_option), default)]
    frequency: Option<f32>,
    #[builder(setter(strip_option), default)]
    entropy: Option<f32>,
    #[builder(setter(skip))]
    f1: f32,
    #[builder(setter(skip))]
    f2: f32,
    #[builder(setter(skip))]
    d1: f32,
    #[builder(setter(skip))]
    d2: f32,
    #[builder(setter(skip))]
    cells: NbIndividuals,
    #[builder(setter(skip))]
    tumour_cells: NbIndividuals,
    #[builder(setter(skip))]
    init_mean: f32,
    #[builder(setter(skip))]
    init_cells: NbIndividuals,
    #[builder(setter(skip))]
    init_copies: Option<DNACopy>,
}

impl ABCResults {
    pub fn save(
        &self,
        path2folder: &Path,
        // subsamples: Option<&NbIndividuals>,
    ) -> anyhow::Result<()> {
        //! Save the results of the abc inference for a run in a folder abc, where there is one file for each (parental) run and the name of the file corresponds to the parental run.
        let path2save = path2folder.to_owned();
        let filename = match self.0[0].parental_idx {
            Some(run) => run.to_string(),
            None => self.0[0].idx.clone(),
        };
        let mut path2file = path2save.join(filename);
        path2file.set_extension("csv");
        fs::create_dir_all(path2file.parent().unwrap())
            .expect("Cannot create dir");
        let mut wtr = if path2file.exists() {
            let wrt = OpenOptions::new()
                .write(true)
                .append(true)
                .open(&path2file)
                .unwrap();

            csv::WriterBuilder::new().has_headers(false).from_writer(wrt)
        } else {
            csv::Writer::from_path(path2file)?
        };
        for record in self.0.iter() {
            wtr.serialize(record)?;
            wtr.flush()?;
        }
        Ok(())
    }
}

/// The main trait for the `Measurement` which defines how to compare the `Run`
/// against the `Measurement`. Types that are `Measurement` must implement
/// `Distance`
///
/// # How can I implement `Distance`?
/// An example of `Measurement` comparing the ecDNA copy number mean of the
/// patient against the one simulated by the run:
///
/// ```no_run
/// use ecdna_evo::data::{euclidean_distance, relative_change, Distance};
/// use ecdna_evo::run::{Ended, Run};
///
/// pub struct Mean(pub f32);
///
/// impl Distance for Mean {
///     fn distance(&self, run: &Run<Ended>) -> f32 {
///         //! The run and the patient's data differ when absolute difference
///         //! between the means considering `NMinus` cells is greater than a
///         //! threshold.
///         relative_change(&self.0, &run.get_mean())
///     }
/// }
/// ```

pub trait Distance {
    /// The data differs from the run when the distance between a `Measurement`
    /// according to a certain metric is higher than a threshold
    fn distance(&self, run: &Run<Ended>) -> f32;
}

impl Distance for EcDNADistribution {
    fn distance(&self, run: &Run<Ended>) -> f32 {
        //! The run and the patient's data ecDNA distributions (considering
        //! cells w/o ecDNA) are different if the Kolmogorov-Smirnov statistic
        //! is greater than a certain threshold or if there are less than 10
        //! cells
        // do not compute the KS statistics with less than 10 datapoints
        let too_few_cells =
            self.nb_cells() <= 10u64 || run.nb_cells() <= 10u64;
        if too_few_cells {
            f32::INFINITY
        } else {
            self.ks_distance(run.get_ecdna()).0
        }
    }
}

impl Distance for Mean {
    fn distance(&self, run: &Run<Ended>) -> f32 {
        //! The run and the patient's data differ when the absolute difference
        //! between the means considering `NMinus` cells is greater than a
        //! threshold.
        relative_change(self, run.get_mean())
    }
}

impl Distance for Frequency {
    fn distance(&self, run: &Run<Ended>) -> f32 {
        relative_change(self, run.get_frequency())
    }
}

impl Distance for Entropy {
    fn distance(&self, run: &Run<Ended>) -> f32 {
        //! The run and the patient's data differ when the absolute difference
        //! between the entropies considering `NMinus` cells is greater than a
        //! threshold.
        relative_change(self, run.get_entropy())
    }
}

/// Relative change between two scalars
pub fn relative_change(x1: &f32, &x2: &f32) -> f32 {
    (x1 - x2).abs() / x1
}
