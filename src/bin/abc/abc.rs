//! Perform the approximate Bayesian computation to infer the most probable
//! fitness and death coefficients from the data.
use anyhow::Context;
use serde::Serialize;
use ssa::ecdna::data::EcDNADistribution;
use ssa::ecdna::process::ABC;
use std::fs;
use std::path::Path;

pub enum Input {
    Distribution(EcDNADistribution),
    Summaries(Summaries),
}

pub struct Summaries {
    mean: Option<f32>,
    frequency: Option<f32>,
    entropy: Option<f32>,
}

impl Summaries {
    pub fn new(
        mean: Option<f32>,
        frequency: Option<f32>,
        entropy: Option<f32>,
    ) -> Self {
        assert!(mean.is_some() || frequency.is_some() || entropy.is_some());
        Self { mean, frequency, entropy }
    }
}

/// The data used to perform ABC.
#[derive(Debug)]
pub struct Data {
    distribution: Option<EcDNADistribution>,
    mean: Option<f32>,
    frequency: Option<f32>,
    entropy: Option<f32>,
}

impl Data {
    pub fn from_input(data: Input) -> Self {
        let (distribution, mean, frequency, entropy) = match data {
            Input::Distribution(distribution) => {
                let mean = distribution.compute_mean();
                let frequency = distribution.compute_frequency();
                let entropy = distribution.compute_entropy();
                (
                    Some(distribution),
                    Some(mean),
                    Some(frequency),
                    Some(entropy),
                )
            }
            Input::Summaries(summaries) => {
                (None, summaries.mean, summaries.frequency, summaries.entropy)
            }
        };
        Self { distribution, mean, frequency, entropy }
    }
}

/// Perform the ABC rejection algorithm for one run to infer the most probable
/// values of the rates based on the patient's data.
///
/// ABC infer the most probable values of the birth-death rates (proliferation
/// rates and death rates) by comparing the summary statistics of the run
/// generated by the birth-death process against the summary statistics of the
/// patient's data.
///
/// When testing multiple statistics with ABC, save runs only if all statistics
/// pass the tests
pub struct ABCRejection;

impl ABCRejection {
    pub fn run(run: &ABC, target: &Data) -> ABCResult {
        //! Run the ABC rejection method by comparing the run's data against the
        //! patient's data (`target`).
        let ecdna = if let Some(target_distribution) = &target.distribution {
            let (distance, convergence) =
                target_distribution.ks_distance(run.get_ecdna_distribution());
            if convergence {
                Some(distance)
            } else {
                None
            }
        } else {
            None
        };
        let mean = target.mean.as_ref().map(|target_mean| {
            relative_change(
                target_mean,
                &run.get_ecdna_distribution().compute_mean(),
            )
        });

        let frequency = target.frequency.as_ref().map(|target_frequency| {
            relative_change(
                target_frequency,
                &run.get_ecdna_distribution().compute_frequency(),
            )
        });

        let entropy = target.entropy.as_ref().map(|target_entropy| {
            relative_change(
                target_entropy,
                &run.get_ecdna_distribution().compute_entropy(),
            )
        });

        let rates = *run.get_rates();
        let b0 = rates[0];
        let b1 = rates[1];

        ABCResult { ecdna, mean, frequency, entropy, b0, b1 }
    }
}

#[derive(Debug, Serialize)]
pub struct ABCResult {
    ecdna: Option<f32>,
    mean: Option<f32>,
    frequency: Option<f32>,
    entropy: Option<f32>,
    b0: f32,
    b1: f32,
}

impl ABCResult {
    pub fn save(
        &self,
        path2folder: &Path,
        id: usize,
        verbosity: u8,
    ) -> anyhow::Result<()> {
        fs::create_dir_all(path2folder.join("abc"))
            .with_context(|| "Cannot create dir abc".to_string())?;
        let mut abc = path2folder.join("abc").join(id.to_string());
        abc.set_extension("csv");
        let results = serde_json::to_string(&self)
            .expect("Cannot serialize the results from ABC inference");
        if verbosity > 1 {
            println!("Saving ABC results to {:#?}", abc);
        }
        fs::write(abc, results).with_context(|| {
            "Cannot save the results from ABC inference".to_string()
        })?;
        Ok(())
    }
}

/// Relative change between two scalars
pub fn relative_change(x1: &f32, &x2: &f32) -> f32 {
    (x1 - x2).abs() / x1
}
